#pragma config(Motor,   motor1,        wristMotor,    tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,   motor2,        leftMotor,    tmotorVexIQ, PIDControl, reversed, driveRight, encoder)
#pragma config(Sensor,  port5,  			 gyro,          sensorVexIQ_Gyro)
#pragma config(Motor,   motor6,        rightMotor,     tmotorVexIQ, PIDControl, driveLeft, encoder)
#pragma config(Motor,   motor7,        armMotor,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,   motor12,       clawMotor,     tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//Prototypes & Global Constants & Variable declarations
task displayMyMotorPositions();
long calculateMotorCutOff( int degreesOfTravel, int powerLevel );
bool calculateProgress( int targetPosition, float motorEncoderValue );
void turnDegrees(float degreesToTurn);
void moveToNeutralPosition();
void moveRobot( int targetClawPosition, int targetWristPosition, int targetArmPosition, int armPowerLevel, int drivePowerLevel, float mmToDrive, int drift);

#include "ClawBotGlobalConstants.h"

#include "displayMyMotorPositions.c"
#include "turnDegrees.c"
#include "calculateMotorCutOff.c"
#include "moveToNeutralPosition.c"
#include "moveRobot.c"
#include "calculateProgress.c"



task main() {

	/*
	*	using resetMotorEncoder is best. it allows you to repeated go back to a specific motor position for arm, wrist, stacker and claw movements.
	*	combining it with a timer to cancel motor movement if it gets stalled will stop the robot from freezing forever.
	*
	*	WRISTMOTOR - positive rotates the wrist up towards the top of the robot arm and negative rotates the wrist down towards the bottom of the arm
	*	0 degrees is the starting position underneath the arm
	*	490 is roughly with the wrist bent backwards flat against the top of the arm
	*
	*	ARM MOTOR(s) positive rotates the arm up and towards the back of the robot and negative rotates it down towards the stabilizing wheels
	*	0   degrees is the starting position with the arm between the "feet"
	*	955 degrees is with the arm fully backwards in reverse block pickup position
	*
	*	clawMotor negative opens the claw and positive closes the claw
	* 	0 degrees is with the tips of the claw gripper touching but not fully clenched
	*	-87 is about as far as it can open between the feet / wheels
	*	-145 degrees is wide as it can go
	*/

	//	int powerLevel = 100;
	//	int leftMotorSpeed, rightMotorSpeed, wristMotorSpeed, armMotorSpeed;
	long timeIn1mSec;
	float timeInSeconds, mmToDrive;
	int targetClawPosition, targetWristPosition, targetArmPosition, armPowerLevel, drivePowerLevel;
	//	int blockGrabbingStep = 0, blockStackingStep = 0;


	resetMotorEncoder(armMotor);
	resetMotorEncoder(clawMotor);
	resetMotorEncoder(wristMotor);

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	resetGyro(gyro);
	startGyroCalibration(gyro, gyroCalibrateSamples2048);
	eraseDisplay();
	getGyroCalibrationFlag(gyro);
	displayString(3, "calibrating gyro");
	wait1Msec(500);
	eraseDisplay();

	startTask(displayMyMotorPositions);

	clearTimer(T3);
	// Start our run


	//Raise the arm off of the ground while driving to the position to pick up the first blocks
	targetClawPosition = 0;
	targetWristPosition = 0;
	targetArmPosition = 250;
	armPowerLevel = 55;
	mmToDrive = - 515.0;
	drivePowerLevel = 100;
	moveRobot( targetClawPosition, targetWristPosition, targetArmPosition, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_MODERATE_RIGHT);
	//wait1Msec(50);

	//get into Reverse Grip position
	mmToDrive = 0.0;
	armPowerLevel = 50;
	moveRobot( FULL_OPEN_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, STOP_WHEELS, mmToDrive, STRAIGHT);

	//grab the blocks
	armPowerLevel = 100;
	moveRobot( CARRY_BLOCKS_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, STOP_WHEELS, mmToDrive, STRAIGHT);

	//pull forward to pick up the blocks
	mmToDrive = 210.0;
	armPowerLevel = 100;
	drivePowerLevel = 100;
	moveRobot( PICKUP_BLOCK_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_MODERATE_RIGHT);
	wait1Msec(100);

	//pick up blocks and put them in the carrying position
	mmToDrive = 0.0;
	armPowerLevel = 100;
	moveRobot( PICKUP_BLOCK_CLAW, CARRY_BLOCKS_WRIST, CARRY_BLOCKS_ARM, armPowerLevel, STOP_WHEELS, mmToDrive, STRAIGHT);
	wait1Msec(100);

	//Left wheels pull off the ground on start so drift far right for a bit
	mmToDrive = 100.0;
	drivePowerLevel = 75;
	moveRobot( PICKUP_BLOCK_CLAW, CARRY_BLOCKS_WRIST, CARRY_BLOCKS_ARM, STOP_ARM, drivePowerLevel, mmToDrive, DRIFT_FAR_RIGHT);

	//Drive to green stacking block hit wall first then backup
	mmToDrive = 1080.0;
	drivePowerLevel = 75;
	moveRobot( PICKUP_BLOCK_CLAW, CARRY_BLOCKS_WRIST, CARRY_BLOCKS_ARM, STOP_ARM, drivePowerLevel, mmToDrive, DRIFT_RIGHT);
	wait1Msec(100);


	//Back up from wall
	mmToDrive = -210.0;
	drivePowerLevel = 75;
	moveRobot( PICKUP_BLOCK_CLAW, CARRY_BLOCKS_WRIST, CARRY_BLOCKS_ARM, STOP_ARM, drivePowerLevel, mmToDrive, DRIFT_MODERATE_RIGHT);
	wait1Msec(50);


	//Stack first 2 blocks
	mmToDrive = 0.0;
	armPowerLevel = 50;
	moveRobot( PICKUP_BLOCK_CLAW, STACK_BLOCKS_LOW_WRIST, STACK_BLOCKS_LOW_ARM, armPowerLevel, STOP_WHEELS, mmToDrive, DRIFT_RIGHT);
	wait1Msec(200);

	//open claw to release block stack
	moveRobot( WHEEL_WELL_OPEN_CLAW, STACK_BLOCKS_LOW_WRIST, STACK_BLOCKS_LOW_ARM, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_RIGHT);
	wait1Msec(100);

	//Drive back to Grab remainder of the first row
	mmToDrive = -1000.0;
	armPowerLevel = 45;
	drivePowerLevel = 100;
	moveRobot( FULL_OPEN_CLAW, STACK_BLOCKS_HIGH_WRIST, STACK_BLOCKS_HIGH_ARM, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_FAR_RIGHT);

	//Drive back to Grab remainder of the first row
	mmToDrive = -890.0;
	armPowerLevel = 45;
	drivePowerLevel = 100;
	moveRobot( FULL_OPEN_CLAW, STACK_BLOCKS_HIGH_WRIST, STACK_BLOCKS_HIGH_ARM, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_MODERATE_RIGHT);

	//get into Reverse Grip position
	mmToDrive = 0.0;
	armPowerLevel = 60;
	moveRobot( FULL_OPEN_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, STOP_WHEELS, mmToDrive, STRAIGHT);

	//grab the blocks
	mmToDrive = 0.0;
	armPowerLevel = 100;
	moveRobot( CARRY_BLOCKS_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, STOP_WHEELS, mmToDrive, STRAIGHT);
	//wait1Msec(100);

	//pull row 1 forward to scoring zone
	mmToDrive = 1610.0;
	armPowerLevel = 100;
	drivePowerLevel = 100;
	moveRobot( PICKUP_BLOCK_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_FAR_RIGHT);
	wait1Msec(100);


	//Open claw
	mmToDrive = 0;
	armPowerLevel = 100;
	drivePowerLevel = 100;
	moveRobot( FULL_OPEN_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, drivePowerLevel, mmToDrive, STRAIGHT);
	wait1Msec(100);

	//put arm in carrying position while backing up
	mmToDrive = -650.0;
	armPowerLevel = 100;
	drivePowerLevel = 100;
	moveRobot( FULL_OPEN_CLAW, CARRY_BLOCKS_WRIST, CARRY_BLOCKS_ARM, armPowerLevel, drivePowerLevel, mmToDrive, STRAIGHT);
	wait1Msec(100);


	//Turn left 80 degrees
	turnDegrees( 80.0);


	//Drive forward until hitting the wall
	mmToDrive = 950.0;
	armPowerLevel = 100;
	drivePowerLevel = 100;
	moveRobot( WHEEL_WELL_OPEN_CLAW, AIM_BLOCKS_HIGH_WRIST, AIM_BLOCKS_HIGH_ARM, armPowerLevel, drivePowerLevel, mmToDrive, STRAIGHT);
	wait1Msec(100);

	//back away from the wall
	mmToDrive = -65.0;
	armPowerLevel = 100;
	drivePowerLevel = 100;
	moveRobot( WHEEL_WELL_OPEN_CLAW, AIM_BLOCKS_HIGH_WRIST, AIM_BLOCKS_HIGH_ARM, armPowerLevel, drivePowerLevel, mmToDrive, STRAIGHT);
	wait1Msec(100);

	//Turn right
	turnDegrees( -95.0);

	//Drive backward while drifting right to hug the wall until we hit it
	mmToDrive = -1200.0;
	armPowerLevel = 100;
	drivePowerLevel = 100;
	moveRobot( WHEEL_WELL_OPEN_CLAW, AIM_BLOCKS_HIGH_WRIST, AIM_BLOCKS_HIGH_ARM, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_RIGHT);
	wait1Msec(100);

	//back up to drop the arm
	mmToDrive = 230.0;
	armPowerLevel = 50;
	drivePowerLevel = 100;
	moveRobot( FULL_OPEN_CLAW, REVERSE_GRIP_WRIST, AIM_REVERSE_GRIP_ARM, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_LEFT);
	//Grab row


	//get into Reverse Grip position
	mmToDrive = 0.0;
	armPowerLevel = 50;
	drivePowerLevel = 0;
	moveRobot( FULL_OPEN_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, STOP_WHEELS, mmToDrive, STRAIGHT);
	//wait1Msec(100);

	//grab the blocks
	mmToDrive = 0.0;
	armPowerLevel = 100;
	moveRobot( CARRY_BLOCKS_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, STOP_WHEELS, mmToDrive, STRAIGHT);
	//wait1Msec(100);

	//pull forward to drag blocks to scoring zone
	mmToDrive = 1600.0;
	armPowerLevel = 100;
	drivePowerLevel = 100;
	moveRobot( PICKUP_BLOCK_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_LEFT);
	wait1Msec(100);


	//Let go of the blocks
	mmToDrive = 0.0;
	armPowerLevel = 100;
	moveRobot( FULL_OPEN_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, STOP_WHEELS, mmToDrive, STRAIGHT);
	//wait1Msec(100);

	//backup to clear the line of blocks
	mmToDrive = -800.0;
	armPowerLevel = 100;
	drivePowerLevel = 100;
	moveRobot( PICKUP_BLOCK_CLAW, REVERSE_GRIP_WRIST, REVERSE_GRIP_ARM, armPowerLevel, drivePowerLevel, mmToDrive, DRIFT_LEFT);

	//go over red blocks and grab them
			//TODO


	//move to stacking position red
			//TODO


	moveToNeutralPosition();

	// Print out the total time it took to do our run

	timeIn1mSec = time1(T3);
	timeInSeconds = timeIn1mSec / 1000.0;

	stopTask(displayMyMotorPositions);

	eraseDisplay();
	displayString(3, "Elapsed Time: %f", timeInSeconds);


	repeat(10) {
		wait1Msec(1000);
	}

}
